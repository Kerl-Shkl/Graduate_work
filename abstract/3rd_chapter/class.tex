%! TEX root = ../main.tex

\section{Набор классов для нахождения контрольной суммы}

Помимо макроса для нахождения контрольной суммы в ходе работы были реализованы
модули, обеспечивающие нахождение контрольной суммы различных секций программ,
загруженных в память и расположенных на диске.

Модули представляют из себя набор из трех классов, написанных на языке C++,
который состоит из:
\begin{itemize}
  \item \verb!CRC_general!--- базовый абстрактный класс, в котором реализованы
    основная логика работы с секциями и алгоритм нахождения контрольной суммы.
  \item \verb!CRC_exe! --- унаследованный от \verb!CRC_general! класс,
    реализующий работу с исполняемыми файлами, расположенными на диске.
  \item \verb!CRC_image! --- унаследованный от \verb!CRC_general! класс,
    реализующий работу с исполняемыми файлами, загруженными в оперативную
    память.
\end{itemize}

Различия в работе с секциями исполняемых файлов, один из который хранится на
диске, а другой загружен в память, заключаются в разных значениях смещений
внутри кода. В таблице секций PE-формата для каждой секции содержится два поля:
\verb!VirtualAddress! и \verb!PointerToRawData!. В поле \verb!VirtualAddress!
содержится относительный виртуальный адрес секции при загрузке программы в
памяти. В свою очередь, поле \verb!PointerToRawData! содержит смещение
относительно начала \textit{файла}, по которому расположена данная секция.

Еще одно отличие заключается в том, что при работе с процессом, расположенном на
диске, базовым адресом загрузки нужно считать начало файла. При этом
необходимо учитывать, что адреса, вычисляемые по таблице релокаций,
соответствуют смещению секций не внутри файла, а внутри программы загруженной в
память.

Реализованные модули следует использовать не для организации защиты приложения,
а для скорее для отладки. В связи с этим реализованный в них алгоритм отличается
от представленного на рисунке \ref{fig:algorithm}. Для нахождения контрольной
суммы все адреса из таблицы релокаций заносятся в ассоциативный контейнер
(\verb!std::set!). При подсчеты контрольной суммы, если адрес проверяемого байта
содержится в этом контейнере, то этот и следующие за ним три байта игнорируются.
Также данные классы позволяют находить контрольную сумму любых секций. Для этого
им необходимо передать битовую маску, соответствующую характеристикам секции.

Также в данных классах реализована система логирования, настраиваемая с помощью
директив препроцессора. Так, например, можно указать файл, в который будут
записаны все значения из таблицы релокаций, или все значения байт с их адресам,
которые вошли в контрольную сумму.

Класс \verb!CRC_exe! реализует еще одну важную функцию. Защищаемая программа
после нахождения своей контрольной суммы должна сравнить ее с эталонным
значением. Эталонное значение должно хранится в другой секции данной программы.
Класс \verb!CRC_exe! позволяет записать найденное значение контрольной суммы в
файл расположенный на диске. 

Защищаемая программа должна разместить в своей памяти ключ размером в четыре
байта. Если защищаемая программа будет проверять целостность своей секции кода,
то ключ можно расположить в секции инициализированных данных (.data). Сделать
это можно путем объявления глобальной переменной, проинициализировав ее
значением ключа. Так как в коде программы значение данной переменной меняться не
будет, ее следует пометить как \verb!volatile!. Иначе компилятор может
попытаться оптимизировать обращение к данной переменной, и просто подставит
значение данной переменной в код программы, вместо того чтобы читать это
значение из адреса памяти. Пример объявления такой переменной:
\begin{verbatim}
  volatile uint32_t CRC = 0x4C52454B;
\end{verbatim}

Класс \verb!CRC_exe! позволяет записать значение контрольной суммы выбранной
секции во все места, где в программе встретится ключевое значение. Для этого
можно применить следующий код:
\begin{verbatim}
  CRC_exe crc_finder;
  uint32_t crc;
  crc_finder.read_file("file_name.exe");
  crc = crc_finder.get_sections_CRC(IMAGE_SCN_CNT_CODE);
  crc_finder.replace_all_keys(KEY, crc);
  crc_finder.write_file("new_file_name.exe");
\end{verbatim}

