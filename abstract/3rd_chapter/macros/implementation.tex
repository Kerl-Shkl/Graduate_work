%! TEX root = ../../main.tex

\section{Реализация алгоритма}

В данной работе приведенный алгоритм реализован на языке ассемблера. Сам
ассемблерный код реализован в виде макроса. Преимуществом такого подхода
является то, что при вызове функции-макроса происходит не вызов функции, а
подстановка кода функции на место вызова. То есть это работает аналогично
встраиваемым функциям. Однако, если попытаться сделать функцию, содержащую код
алгоритма, встраиваемой, то компилятор проигнорирует ключевое слово
\verb!inline!. Для компилятора MSVC данная проблема решается ключевым словом
\verb!__forceinline!, но, например, если поменять компилятор на gcc, то такое
решение уже не подойдет.  Для обеспечения универсальности кода по отношению к
компилятору реализация алгоритма помещена в макрос.

Использование макроса предоставляет еще одну полезную возможность, а именно
указать при вызове разный порядок регистров. Таким образом, вызывая
макрос с разным порядком регистров, будут получаться разные участки кода. Если
злоумышленник найдет и исправит один блок защиты, то найти остальные путем
поиска повторяющихся элементов памяти у него не получится.

Объявление макроса выглядит следующим образом:
\begin{verbatim}
  #define GET_CRC(reg_A, reg_B, reg_C, \
                  reg_D, reg_SI, reg_DI, out_var) ...
\end{verbatim}
В качестве регистра при вызове макроса необходимо передать букву, которая его
обозначает. Для \verb!eax! необходимо передать \verb!a!, для \verb!ebx! ---
\verb!b! и так далее. Только для регистров \verb!esi! и \verb!edi! необходимо
передать \verb!si! и \verb!di! соответственно. Это связано с тем, что при работе
с этими регистрами невозможно обратиться к их младшему байту.

Внутри макроса имена регистров соединяются при помощи псевдооперации \verb!##!.
Так, например, строчка кода
\begin{verbatim}
  mov al, byte ptr [ebx]
\end{verbatim}
принимает вид
\begin{verbatim}
  mov reg_A##l, byte ptr [e##reg_B##x]
\end{verbatim}

При оформлении кода ассемблера в виде макроса приходится учитывать следующие
правила:
\begin{enumerate}
  \item Заключить код в \verb!__asm{...}! блок.
  \item Поместить ключевое слово \verb!__asm! перед каждой ассемблерной
    инструкцией.
  \item Использовать только блочные комментарии (\verb!/*...*/!).
\end{enumerate}
Эти правила обусловлены тем, что при подстановке макроса он всегда занимает
только одну строку.

Первое правило необходимо соблюдать, чтобы макрос можно было использовать в
одной строке с другим кодом языка C или C++. Без закрывающей фигурной скобки
компилятор не сможет понять, где заканчивается ассемблерный код, и будет
воспринимать код C или C++ как ассемблерные инструкции.

Второе правило обусловлено тем, что ключевое слово \verb!__asm! и перевод строки
являются единственными разделителями операторов в ассемблерных вставках. Из-за
того, что подстановка макроса происходит в одну строку, из доступных
разделителей операторов остается только ключевое слово \verb!__asm!.

Третье правило ограничивает использование строчных комментариев, так как первый
строчный комментарий сделает всю оставшуюся часть макроса комментарием.

Также при разработке макроса пришлось столкнуться с проблемой невозможности
установки меток внутри ассемблерной вставки. Чтобы установить метку,
необходимо закрыть блок ассемблерной вставки, установить метку и открыть новую
ассемблерную вставку.

Ниже приведен пример корректного макроса с ассемблерной вставкой.
\begin{verbatim}
  #define EXAMPLE_MACRO(out_var) __asm \
  { \
    __asm mov eax, value    /* Place value in eax */ \
    __asm cmp eax, svalue   /* Compare first and second value */ \
    __asm je l1 \
    __asm mov out_var, eax \ 
    __asm jmp end \
  } \
  l1: \
  __asm { \
    __asm add eax, 0x200    /* Increase eax by 200 */ \
    __asm mov out_var, eax \
  } \
  end:
\end{verbatim}
