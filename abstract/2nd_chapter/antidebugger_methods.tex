%! TEX root = ../main.tex

\section{Обзор методов защиты от отладчика}
Как было отмечено в предыдущей главе, отладчик может предоставить
злоумышленникам большой инструментарий по взлому программы. Следовательно,
необходимо разработать механизм, который будет препятствовать работе отладчика.
Рассмотрим несколько способов обнаружить, что программа работает под отладчиком.

\subsection{Возможности предоставляемые операционной системой}
Операционная система Windows предоставляет следующие функции:
\begin{verbatim}
  BOOL IsDebuggerPresent();
  BOOL CheckRemoteDebuggerPresent(
      [in]    HANDLE hProcess,
      [out]   PBOOL pbDebuggerPresent );
\end{verbatim}

Первая функция позволяет понять находится ли процесс, который совершил вызов,
под отладчиком. Если процесс выполняется под отладчиком, то функция вернет
ненулевое значение, а иначе вернет ноль.

Вторая функция принимает первым параметром дескриптор процесса, а вторым
указатель на переменную типа \verb!BOOL!, в которую функция занесет \verb!TRUE!,
если указанный процесс выполняется под отладчиком, или \verb!FALSE!, если
отладчика нет. Функция возвращает ненулевое значение в случае успеха и ноль,
если произошла ошибка.

Недостаток метода основанного на данных функциях заключается в его очевидности.
Большинство отладчиков имеют расширения, которые позволяют обойти проверку
данных функций.

\subsection{Замер времени выполнения}
При отладке программы время выполнения инструкций многократно увеличивается, так
как программа выполняется пошагово. Можно замерить время выполнения участка
кода, и если время выполнения этого участка окажется сильно больше планируемого
при штатной работе (например несколько секунд), то можно сделать вывод, что
программа выполняется под отладчиком.

Есть несколько доступных способов замерить время выполнения участка программы:
\begin{itemize}
  \item Использовать инструкцию \verb!rdtsc!. Эта инструкция считывает текущее
    значение счетчика меток времени процессора (64-битный \verb!MSR!) в регистры
    \verb!EDX:EAX!. В регистр \verb!EDX! загружаются старшие 32 бита \verb!MSR!,
    а в регистр \verb!EAX! младшие 32 бита. В коде такую проверку можно
    представить следующим образом:
    \begin{verbatim}
    rdtsc
    xchg  esi, eax
    mov   edi, edx
    rdtsc
    sub   eax, esi
    subb  edx, edi
    jne   _being_debugged
    cmp   eax, elapsed ; elapsed содержит максимальное
                       ; время выполнения участка кода
    jnbe  _being_debugged
    \end{verbatim}

  \item Использовать API операционной системы Windows:
    \begin{itemize}
      \item Функции работы со временем \verb!GetSystemTime! или
        \verb!GetLocalTime!. В этом случае придется переводить полученной время
        в 8-байтовое число, чтобы можно было посчитать разницу между двумя
        значениями времени.
      \item Функции счетчики, которые возвращают количество миллисекунд
        (микросекунд) с момента запуска системы. Это соответственно функции
        \verb!GetTickCount! и \verb!QueryPerformanceCounter!. При использовании
        этих функций переводить время в число не требуется, что делает их более
        предпочтительными.
    \end{itemize}

  \item Прочитать время с платы CMOS. Но, чтобы получить доступ к портам
    ввода/вывода, необходимо установить соответствующий драйвер.
\end{itemize}

\subsection{Нахождение контрольной суммы участка кода}
Данная работа посвящена реализации самого трудоемкого и сложного метода защиты
от отладчика. Суть метода заключается в том, чтобы посчитать контрольную сумму
участка кода программы и занести в одну из переменных. При необходимости
проверки наличия отладчика программа будет проверять соответствует ли текущее
значение контрольной суммы кода сохраненному ранее значению. 

Преимуществом данного метода является то, что он не только позволяет обнаружить
отладчик, но и защищает программу от любых изменений вносимых в ее код. Также
в работе будет рассмотрен способ нахождения контрольной суммы без обращения к
системным вызовам, что дополнительно усложняет нахождение участка защиты.

Рассмотрим проблемы и особенности, с которыми предстоит столкнуться при
реализации данного метода.
